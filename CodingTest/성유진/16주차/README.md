## [댄스 파티](https://www.acmicpc.net/problem/2831)
### 문제 풀이 방식
풀이가 떠오르지 않아 문제 유형을 보고 풀었습니다...  
우선 부호가 달라야 하기 때문에 입력받은 수를 부호와 성별에 따라서 4개의 리스트로 받고, 부호가 다른 남녀를 함수의 인자로 넣어서 투포인터로 확인해주었습니다.  
양수인 그룹에서 가장 큰 수부터 확인하면서 가능한지 확인해주기 위해서 모든 리스트는 절대값의 역순(키순)으로 정렬하였습니다.

plus(양수인 그룹)에서 가장 큰 수를 minus(음수인 그룹)에서 절댓값이 가장 큰 수와 비교하여
- 불가능하면 하나 더 작은 수를 확인하기 위해서 p를 증가
- 가능하면 p와 m 모두 증가하여 다음 사람을 확인합니다. + 횟수 증가

```java
int p = 0;
int m = 0;
int cnt = 0;
while (p < plus.length && m < minus.length) {
  if (plus[p] < minus[m]) { // plus의 값이 더 작아야함
    cnt++;
    p++;
    m++;
  } else {
    p++;
  }
}
```

## [돌 그룹](https://www.acmicpc.net/problem/12886)
### 문제 풀이 방식
예제만 통과하게 백트래킹으로 풀었는데 역시나 틀렸고 문제 유형을 봐도 풀이가 떠오르지 않아 블로그를 참고하여 풀었습니다.

현재 돌의 그룹에서 만들어질 수 있는 모든 돌의 그룹을 BFS로 탐색하여 돌의 그룹 개수가 동일해지는 경우를 찾았습니다.  
visited 배열로 똑같은 돌의 개수로 분배하는 경우를 다시 방문하는 것을 방지하였습니다. 그리고 돌의 개수만큼 3차원으로 배열을 만들면 메모리 초과가 난다고 하여 두개의 돌의 개수로만 visited를 기록하였습니다. (어차피 두개의 돌의 개수를 알면 나머지 하나도 알 수 있기 때문)
