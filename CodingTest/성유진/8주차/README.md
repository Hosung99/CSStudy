## [좋다](https://www.acmicpc.net/problem/1253)
### 문제 풀이 방식
**입력받은 수열을 순회하면서 두 개의 숫자를 고르고, 두 숫자를 더한 수가 해당 수열에 존재하는지** 를 판단하여 문제를 해결하였습니다.  
하지만, 두 숫자를 더한 수의 존재여부를 다시 배열을 순회하여 확인하면 시간초과가 발생할 듯 하여 HashMap을 활용하여 O(1) 시간에 확인할 수 있도록 하였습니다.

즉, 입력 받은 수열을 배열과 HashMap에 모두 저장합니다.
- A(배열) : 입력받은 숫자를 그대로 저장
- M(맵) : key는 입력받은 수, value는 해당 수의 개수로 저장

*`수의 위치가 다르면 값이 같아도 다른 수이다.`* 라는 조건이 있어서 Set을 활용하려다가 중복되는 숫자의 개수까지 저장할 수 있도록 Map을 활용하였습니다.  
또한 좋은 수의 개수를 구할 때에 같은 수인 경우면 해당 수의 cnt를 Map 저장된 개수만큼 증가시켜주고 해당 숫자를 Map에서 제거해주었습니다.

```java
for (int i = 0; i < N - 1; i++) {
  for (int j = i + 1; j < N; j++) {
    int sumVal = A[i] + A[j]; // 배열 순회하며 선택한 두 수를 더한 값
    if (M.containsKey(sumVal) && !isSelf(A[i], A[j])) {
      cnt += M.get(sumVal); // 개수만큼 반영
      M.remove(sumVal);     // 맵에서 제거
    }
  }
}
```

예를 들어 `1 1 2 2 2 2 2` 와 같은 입력이 들어온다면,  
{1:2, 2:5} 와 같은 형식으로 Map에 저장하고, sumVal이 2가 되면 cnt에 M[2]의 값인 5를 더해주고, M에서 2를 제거합니다.

`0 -1 1` 와 같은 경우 예외처리를 하기 위해서 isSelf 함수를 만들었습니다.
기존 로직에 따르면 0 + (-1) = -1 로 -1이 Map에 존재하기 때문에 cnt가 증가합니다. 하지만 자기 자신이 포함되어 있기 때문에 cnt를 증가시키지 않아야 합니다.

```java
public static boolean isSelf(int a, int b) {
  int sumVal = a + b;
  if (a == sumVal && M.get(a) == 1) 
    return true;
  if (b == sumVal && M.get(b) == 1)
    return true;
  if (a == b && a == sumVal && M.get(a) == 2) // 0 0 에 대한 예외처리
    return true;
  return false;
}
```

## [택배](https://www.acmicpc.net/problem/8980)
### 문제 풀이 방식

마을 번호 순서대로 택배를 일단 모두 실을 수 있을만큼 싣고, 목적지 상관없이 도착지마다 가지고있는 택배를 무조건 최대로 내리도록 구현했었습니다. 하지만 틀린 이유도 모르겠어서,, 아래 블로그에서 반례와 풀이를 참고하였습니다.  
https://ddiyeon.tistory.com/36

반례는 아래와 같았습니다.
```
5 30
5
1 2 30
1 3 20
2 5 30
3 4 10
4 5 10
# 틀린 답:80
# 답:70
```
즉, 출발지에서부터 실은 박스가 아닌 그냥 아무데서나 실은 박스를 배송하였다고 하는 이상한 코드였던 것입니다...ㅎ

옳은 구현 방법은 **가장 먼저 도착할 수 있는 택배부터** 배달하도록 구현하면 되었습니다. 따라서 입력받은 배달 정보들을 도착지가 빠른 기준으로 정렬하였고, 정렬된 순서대로 각 마을에서 택배를 실을 수 있는 용량을 배열에 저장하여 확인하도록 구현하였습니다.
