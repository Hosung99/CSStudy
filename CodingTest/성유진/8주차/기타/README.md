## [성적평균](https://softeer.ai/practice/6294)
### 문제 풀이 방식
그냥 반복문으로 더해가면서 풀었는데 맞더군요..?  
근데 이러면 배우는게 없으니까 누적합을 활용해서 풀어보았습니다.

sumS에 첫번쨰 인덱스부터 해당 인덱스까지의 수를 더한 값을 저장합니다.  
`int _sum = sumS[b] - sumS[a - 1];` a부터 b의 성적 합은 이와 같이 구해주었습니다.



## [징검다리](https://softeer.ai/practice/6293)
### 문제 풀이 방식

처음에 스택 활용 문제인줄 알았으나 DP 문제더라고요!  
반례를 스스로 생각해내지 못해서 질문 게시판..?을 참고 하였습니다.

제가 참고한 반례는 아래와 같습니다.
```
9
2 1 7 8 11 3 4 5 6
# 틀린 답 : 2 7 8 11 -> 4 
# 답 : 2(1) 3 4 5 6 -> 5
```

건너온 다리중에 현재 다리보다는 더 낮으면서 가장 많은 횟수로 건넌 다리를 확인해야 겠다고 생각하였습니다.  
그래서 각 다리위치마다 건너온 최대 횟수를 저장하는 배열을 만들어서 DP로 해결하였습니다.
```java
for (int i = 1; i < N; i++) {
  for (int j = 0; j < i; j++) {
    if (A[i] > A[j]) { // 더 낮은 다리인지 확인
      dp[i] = Math.max(dp[i], dp[j] + 1); // 가장 많은 횟수 확인
    }
  }
}
```
