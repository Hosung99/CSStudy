## [가장 긴 짝수 연속한 부분 수열 (large)](https://www.acmicpc.net/problem/22862)
### 문제 풀이 방식
투포인터 유형을 많이 안 풀어봐서 그런지 이상한 방법으로 헤매다가 블로그를 참조하여 해결하였습니다..~
https://velog.io/@pppp0722/%EB%B0%B1%EC%A4%80-%EA%B3%A8%EB%93%9C5-22862-%EA%B0%80%EC%9E%A5-%EA%B8%B4-%EC%A7%9D%EC%88%98-%EC%97%B0%EC%86%8D%ED%95%9C-%EB%B6%80%EB%B6%84-%EC%88%98%EC%97%B4-large-Java

현재 방문한 원소(오른쪽 포인터가 위치한 원소)에 따라서 세가지 경우로 나누어서 탐색하도록 하였습니다.
1. 짝수인 경우
2. 홀수이면서 원소 삭제가 불가능한 경우
3. 홀수이면서 원소 삭제가 가능한 경우

각각의 경우에 따라서 아래와 같이 구현하였습니다.

```java
// 1. 짝수
if (S[r] % 2 == 0) {
  r++;
  result = Math.max(result, r - l - rmv);
}
// 2. 홀수 & 기회 없음
else if (rmv == K) { 
  if (S[l] % 2 != 0) { // l에 위치한 원소가 홀수이면
    rmv--; // 원소 삭제 횟수 감소
  }
  l++;
}
// 3. 홀수 & 기회 있음
else {  
  rmv++; // 원소 삭제 횟수 증가
  r++;
  result = Math.max(result, r - l - rmv);
}
```


## [배열 돌리기1](https://www.acmicpc.net/problem/16926)
### 문제 풀이 방식
하나의 배열을 여러개의 사각형으로 나누어서 생각하였습니다.
예제1과 같이 4X4 사각형이면 아래와 같이 두개의 사각형으로 나누어서 회전하도록 하였습니다.
그래서 한 번의 회전의 경우, 아래와 같이 시작점을 증가시키면서 가장 바깥쪽 사각형부터 안쪽 사각형까지 1씩 회전시킨 결과를 tmp배열에 담아주었습니다.

```java
while (true) {
  if (!(si < N / 2 && sj < M / 2))
    break;
  move(si++, sj++, cnt++);
}
```

그리고 회전 한번의 경우 아래와 같이 상하좌우 이동시키는 위치에 대한 규칙이 존재하였습니다.
해당 규칙에 따라서 move 함수를 구현하였습니다. 가로 세로 크기는 cnt 변수를 통해서 관리되도록 하였습니다.
```
시작점 : (0,0) / 가로 : 4, 세로 4  
L L L U
D     U
D     U
D R R R

시작점 : (1,1) / 가로 : 2, 세로 2  
L U
D R
```