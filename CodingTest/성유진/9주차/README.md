## [가장 긴 짝수 연속한 부분 수열 (large)](https://www.acmicpc.net/problem/22862)
### 문제 풀이 방식
투포인터 유형을 많이 안 풀어봐서 그런지 이상한 방법으로 헤매다가 블로그를 참조하여 해결하였습니다..~
https://velog.io/@pppp0722/%EB%B0%B1%EC%A4%80-%EA%B3%A8%EB%93%9C5-22862-%EA%B0%80%EC%9E%A5-%EA%B8%B4-%EC%A7%9D%EC%88%98-%EC%97%B0%EC%86%8D%ED%95%9C-%EB%B6%80%EB%B6%84-%EC%88%98%EC%97%B4-large-Java

현재 방문한 원소(오른쪽 포인터가 위치한 원소)에 따라서 세가지 경우로 나누어서 탐색하도록 하였습니다.
1. 짝수인 경우
2. 홀수이면서 원소 삭제가 불가능한 경우
3. 홀수이면서 원소 삭제가 가능한 경우

각각의 경우에 따라서 아래와 같이 구현하였습니다.

```java
// 1. 짝수
if (S[r] % 2 == 0) {
  r++;
  result = Math.max(result, r - l - rmv);
}
// 2. 홀수 & 기회 없음
else if (rmv == K) { 
  if (S[l] % 2 != 0) { // l에 위치한 원소가 홀수이면
    rmv--; // 원소 삭제 횟수 감소
  }
  l++;
}
// 3. 홀수 & 기회 있음
else {  
  rmv++; // 원소 삭제 횟수 증가
  r++;
  result = Math.max(result, r - l - rmv);
}
```


## [배열 돌리기1](https://www.acmicpc.net/problem/16926)
### 문제 풀이 방식
하나의 배열을 여러개의 사각형으로 나누어서 생각하였습니다.
예제1과 같이 4X4 사각형이면 아래와 같이 두개의 사각형으로 나누어서 회전하도록 하였습니다.
그래서 한 번의 회전의 경우, 아래와 같이 시작점을 증가시키면서 가장 바깥쪽 사각형부터 안쪽 사각형까지 1씩 회전시킨 결과를 tmp배열에 담아주었습니다.

```java
while (true) {
  if (!(si < N / 2 && sj < M / 2))
    break;
  move(si++, sj++, cnt++);
}
```

그리고 회전 한번의 경우 아래와 같이 상하좌우 이동시키는 위치에 대한 규칙이 존재하였습니다.
해당 규칙에 따라서 move 함수를 구현하였습니다. 가로 세로 크기는 cnt 변수를 통해서 관리되도록 하였습니다.
```
시작점 : (0,0) / 가로 : 4, 세로 4  
L L L U
D     U
D     U
D R R R

시작점 : (1,1) / 가로 : 2, 세로 2  
L U
D R
```

## [사다리 타기](https://www.acmicpc.net/problem/2469)
### 문제 풀이 방식
- topDown : 출발지에서 빈칸까지 사다리 탄 결과
- bottomUp : 도착지에서 빈칸까지 사다리 탄 결과

이 두 가지의 결과를 비교해서 빈칸을 만들어서 해결하였습니다.

사다리 타기는 사다리를 타는 사람의 위치를 i, j로 설정하여 반복문으로 구현하였습니다.  
현재 위치에서 좌우를 확인하여 막대기가 있는지 확인하여 내려갈 방향을 정하고 j인덱스 값을 변경해주었습니다.  
사용자의 위치가 (i, j)인 경우 왼쪽을 확인하는 경우 입력받은 사다리배열의 j-1, 오른쪽의 경우 j인덱스를 확인해주면 되었습니다.

```java
int i = 0;
int j = p;
while (i < blank) {
  if (j != 0 && ladder[i][j-1] == '-') { // 좌
    j--;
  }
  else if (ladder[i][j] == '-') { // 우
    j++;
  }
  i++;
}
```

topDown에서는 사다리 타기의 결과를 tmp이라는 이름의 배열에 담아서 비어있는 칸에 도착한 위치를 저장하였습니다.  
  ex) A가 네번째 줄에 도착 -> tmp[0] = 3, C가 첫번째 줄에 도착 -> tmp[2] = 0

bottomUp에서는 사다리 타기의 결과를 tmp배열의 값과 현재 도착한 위치인 j를 비교하여 정답을 만들어주었습니다.  
정답 배열은 *로 초기화해두었습니다.  
1. 위치가 동일한 경우  
    아무런 동작을 하지 않아도 되지만, 다리가 놓여져 있는 경우에는 잘못 만들어진 사다리라고 판단하여 예외처리를 해주었습니다
2. bottomUp에서의 위치가 한 칸 더 왼쪽에 있는 경우  
    사다리를 왼쪽에 두었습니다.
3. bottomUp에서의 위치가 한 칸 더 오른쪽에 있는 경우  
    사다리를 오른쪽에 두었습니다.
4. 한칸 이상의 차이가 나는 경우  
    불가능한 경우이므로 예외처리를 해주었습니다.

```java
Arrays.fill(ans, '*');
...
if (tmp[p] == j) {
  if (ans[j] == '-') { // 동일한 위치
    System.out.print(wrongAns);
    System.exit(0);
  }
} else if (tmp[p] == j - 1) { // 왼쪽에 사다리
  ans[j-1] = '-';
} else if (tmp[p] == j + 1) { // 오른쪽에 사다리
  ans[j] = '-';
} else {
  System.out.print(wrongAns);
  System.exit(0);
}
```