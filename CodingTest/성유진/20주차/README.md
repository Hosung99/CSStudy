## [연산자 끼워넣기](https://www.acmicpc.net/problem/14888)
### 문제 풀이 방식
오버플로우 안심시켜주는 친절한 문제,,  
각 연산자의 개수를 opCnt 배열에 저장하여, 이 개수를 확인하며 가능한 연산자의 조합을 operators 리스트에 저장하였습니다.  
연산자의 조합이 구해지면 calculate 함수를 이용하여 결과를 계산해서 최댓값, 최솟값을 비교하고 갱신시켜주어서 해결하였습니다.


## [입국심사](https://www.acmicpc.net/problem/3079)
### 문제 풀이 방식
모르겠어서 문제 분류를 보았는데 이분탐색,,? 그래도 모르겠어서 지피티랑 해결했습니다

총 걸리는 시간으로 이분탐색을 진행하고 해당 시간내에 입국심사가 가능한지 여부를 확인(이 부분이 이해가 잘 안갔는데 지피티가 친절하게 알려주더군요)하는 방식으로 해결해야 했습니다.

입국 심사 가능 여부를 아래 possible 함수로 판단해주었습니다.  
처음에는 심사 가능 인원을 직접 구해서 반환해주었는데, 자꾸 틀려서 질문게시판을 찾아보니 time이 크고 입국심사 시간인 T가 작으면 오버플로우가 발생할 수 있어서 그렇다고 하더군요,,  
그래서 최대 사람수인 M을 넘어가면 바로 가능하다고 반환해주는 방식으로 수정하였습니다.

```java
public static boolean possible(long time) {
  long cnt = 0;
  for (int i = 0; i < N; i++) {
    cnt += time / T[i];
    if (cnt >= M) // 오버플로우 방지
      return true;
  }
  return false;
}
```


## [줄어드는 수](https://www.acmicpc.net/problem/1174)
### 문제 풀이 방식
처음에는 줄어드는 수의 한계(9876543210)가 존재한다는 사실을 떠올리지 못해서 1부터 모든 숫자를 증가시키는 수인지 확인하는 방법으로 구현했고, 당연히 불가능,,,했습니다ㅎ

나중에 줄어드는 수의 최대가 정해져있다는 것을 꺠달아서 줄어드는 수를 백트래킹으로 만들면서 N이 되는지 확인하고,  
만드는것이 불가능하면 -1을 출력하는 방법으로 해결하였습니다
