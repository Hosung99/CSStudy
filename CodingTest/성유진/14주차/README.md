## [계란으로 계란치기](https://www.acmicpc.net/problem/16987)
### 문제 풀이 방식
들고 있는 계란으로 깰 수 있는 계란을 확인하는 것을 백트래킹으로 해결하면 되었습니다.  
다음 계란을 무조건 잡아야 한다고 생각해서 solve(hold+1)이 무조건 실행되도록 코드를 짰었는데, 
계란을 깼으면 이미 반복문 내의 solve 함수를 호출했기 때문에, 계란을 깨지 못한 경우에만 호출하도록 고쳐주어야 했습니다.  
이 부분을 생각해내지 못해서 이전에 풀었던 코드를 참고하여 해결하였습니다.

```java
boolean broke = false; // 계란을 깼는지 안 깼는지 확인
for (int i = 0; i < N; i++) {
  if (i != hold && S[i] > 0) {
    S[i] -= W[hold];
    S[hold] -= W[i];
    broke = true;
    solve(hold + 1);
    S[i] += W[hold];
    S[hold] += W[i];
  }
}
// 계란을 깨지 못한 경우, 다음 계란 잡기
if (!broke)
  solve(hold + 1);
```

## [부분수열의 합](https://www.acmicpc.net/problem/1182)
### 문제 풀이 방식
주어진 순열의 모든 조합을 구해서 부분수열을 백트래킹으로 구하면 되는 문제였습니다.  
만들어니 부분 수열의 합을 확인해서 S와 같으면 결과 값을 1씩 더해주었습니다.


## [스도쿠](https://www.acmicpc.net/problem/2580)
### 문제 풀이 방식
비어있는 칸과 가능한 숫자를 map으로 저장해서 구현을 하려 했는데 생각해보니 많이 이상해서 다른 풀이를 참고하고 백트래킹 문제임을 깨달았습니다...
당연히 백트래킹인데 이걸 왜 몰랐지?? 심지어 리드미에 주제도 써있었네요??  
아무튼 분류 알아낸 이후에는 혼자 풀었습니다

풀이 방식은 한칸씩 확인하면서 비어있는 칸(0)이면 1~9 중에 가능한 숫자를 확인하여 칸을 채워주었습니다.


## [죽음의 비](https://www.acmicpc.net/problem/22944)
### 문제 풀이 방식
이번주 주제는 백트래킹이었지만 bfs풀이만 떠올라서 bfs로 풀었습니다  
근데 자꾸 왜 틀리는지 모르겠어서 이전에 풀었던 풀이를 보고 고쳤습니다..

기존에는 원래 bfs 풀던대로 방문시각을 기록하면서 bfs를 순회하고 방문하였으면 지나쳤는데,
이 문제에서는 재방문이 가능해서 **우산내구도와 체력의 합을 기록**하여, 재방문하는 것이 이득인지 아닌지 확인하며 순회해야 했습니다

사실 근데 아직 납득이 안된 부분이 있어요.. 이유를 찾아주신다면 감사하겠습니다ㅎㅎ~  
종료지점을 찾아서 반환하는 조건을 cur를 기준으로 확인하는 것과 새로 만든 ni, nj로 확인하는 것의 정답이 다르게 나오는데 이 이유를 아직 모르겠습니다....

```java
while (!Q.isEmpty()) {
      int[] cur = Q.poll();
      int curi = cur[0];
      int curj = cur[1];
      int curH = cur[2]; // 체력
      int curD = cur[3]; // 우산 내구도
      int curT = cur[4]; // 방문 시각

      // 종료 지점에 도착하면 이동시간 반환 -> 틀림
      if (board[curi][curj] == 'E')
        return curT;
      ////////

      for (int dir = 0; dir < 4; dir++) {
        int ni = curi + di[dir];
        int nj = curj + dj[dir];
        if (ni < 0 || ni >= N || nj < 0 || nj >= N)
          continue;

        // 종료 지점에 도착하면 이동시간 반환 -> 맞음
        if (board[ni][nj] == 'E')
          return curT + 1;
        /////
```
