## [과일 탕후루](https://www.acmicpc.net/problem/30804)
### 문제 풀이 방식
앞뒤 확인해서 종류가 가장 많은 것부터 없애면 되지 않을까라고 생각하여 그리디인가? 라고 생각했는데  
애초에 양쪽이 같은 과일이면 또 다른 기준이 필요해졌고 당연히 아니었습니다...  
근데 모르겠어서 문제 유형을 확인하고 해결하였습니다..ㅎㅎ  

브루트포스와 투포인터여서  
우선은 브루트포스라고 생각하고 2중 반복문으로 확인해야할 인덱스 지정하도록 구현해놓은 뒤에,  
인덱스를 지정하는 부분을 투포인터로 변경하는 방식으로 구현하였습니다.

과일별 개수를 Map에 저장하려 하였으나,  
과일 종류가 9가지 밖에 되지 않아서 시간에도 영향이 없을 것 같고, Map으로 관리하려면 코드가 아래와 같이 훨씬 길어져서  
배열에 담아서 과일 종류 개수를 확인하는 checkCount 함수를 따로 만들어서 관리하였습니다.

- Map으로 관리하는 경우의 과일 추가 및 제거

```java
// 과일 추가
fruits.put(num, fruits.getOrDefault(num, 0) + 1);

// 과일 제거
fruits.put(key, fruits.get(key) - 1);
  if (fruits.get(key) == 0)
    fruits.remove(key);
}
```


## [나이트의 이동](https://www.acmicpc.net/problem/7562)
### 문제 풀이 방식
```java
int[] di = {-2, -2, -1, -1, 1, 1, 2, 2};
int[] dj = {-1, 1, -2, 2, -2, 2, -1, 1};
```
나이트의 이동 방향에 따라서 배열을 만들어주고, bfs를 진행하였습니다.  
dist 배열을 만들어서 각 위치에 도착하는 시간을 저장하고, dist 배열에서 목표 위치의 값을 출력하여 해결하였습니다.