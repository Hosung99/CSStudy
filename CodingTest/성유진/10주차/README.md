## [과일 탕후루](https://www.acmicpc.net/problem/30804)
### 문제 풀이 방식
앞뒤 확인해서 종류가 가장 많은 것부터 없애면 되지 않을까라고 생각하여 그리디인가? 라고 생각했는데  
애초에 양쪽이 같은 과일이면 또 다른 기준이 필요해졌고 당연히 아니었습니다...  
근데 모르겠어서 문제 유형을 확인하고 해결하였습니다..ㅎㅎ  

브루트포스와 투포인터여서  
우선은 브루트포스라고 생각하고 2중 반복문으로 확인해야할 인덱스 지정하도록 구현해놓은 뒤에,  
인덱스를 지정하는 부분을 투포인터로 변경하는 방식으로 구현하였습니다.

과일별 개수를 Map에 저장하려 하였으나,  
과일 종류가 9가지 밖에 되지 않아서 시간에도 영향이 없을 것 같고, Map으로 관리하려면 코드가 아래와 같이 훨씬 길어져서  
배열에 담아서 과일 종류 개수를 확인하는 checkCount 함수를 따로 만들어서 관리하였습니다.

- Map으로 관리하는 경우의 과일 추가 및 제거

```java
// 과일 추가
fruits.put(num, fruits.getOrDefault(num, 0) + 1);

// 과일 제거
fruits.put(key, fruits.get(key) - 1);
  if (fruits.get(key) == 0)
    fruits.remove(key);
}
```


## [나이트의 이동](https://www.acmicpc.net/problem/7562)
### 문제 풀이 방식
```java
int[] di = {-2, -2, -1, -1, 1, 1, 2, 2};
int[] dj = {-1, 1, -2, 2, -2, 2, -1, 1};
```
나이트의 이동 방향에 따라서 배열을 만들어주고, bfs를 진행하였습니다.  
dist 배열을 만들어서 각 위치에 도착하는 시간을 저장하고, dist 배열에서 목표 위치의 값을 출력하여 해결하였습니다.



## [인간-컴퓨터 상호작용](https://www.acmicpc.net/problem/16139)
### 문제 풀이 방식
**문자마다 누적합 구하기**  
우선 인자로 전달받은 문자의 개수를 배열로 만들어서 반환하는 `noteCount` 함수를 만들어서 문자열에 존재하는 특정 문자의 개수를 누적합으로 구하였습니다.

**알파벳별 누적합 배열 Map으로 관리**  
이렇게 하면 50점은 나올 것 같은데, 질문의 개수가 많아지는 경우 시간초과가 발생할 듯하여서, 찾으려는 알파벳을 키로, 그에 따른 누적합 배열을 값으로 가지는 `count`라는 이름의 map을 만들어 관리하였습니다.  
질문으로 들어온 알파벳이 map에 존재하는지 확인하여 저장된 누적합 배열을 활용하여 시간을 절약하도록 하였습니다.

**`StringBuilder` 활용**  
위에 두가지 방법을 활용하면 무조건!!!! 시간 초과가 발생하지 않을 것이라고 생각했는데 계속 50점이 나와서 진짜 한참을... 헤메었는데  
질문게시판을 보다가 입력을 Scanner로 받으면 안 된다는 글이 있었고, 해결한 코드에 출력 함수도 한번만 호출한 것을 보았습니다.
그래서 `StringBuilder` 를 사용하여 정답 문자열을 만든 이후에 한번에 출력하도록 하여 해결하였습니다...