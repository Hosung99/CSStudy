## [공유기 설치](https://www.acmicpc.net/problem/2110)
### 문제 풀이 방식
양 끝 집에 공유기를 설치한 후, 남은 공유기를 이미 설치된 공유기와 최대한 멀리 설치하려고 하였습니다. 하지만 설치할 위치에 대한 명확한 기준을 세울수 없었고 그외의 풀이는 생각나지 않아서 다른 풀이를 참고하였습니다.  
항상 이진 탐색인 것은 깨닫는데 문제 풀이 자체를 떠올리지 못하네요,, 이진탐색 문제를 많이 풀어봐야 겠습니다..!

아무튼 그래서 보장해야 하는 최대 거리를 1부터 가장 먼 두 공유기의 거리까지 이진 탐색하며, 해당 거리를 보장하면서 설치 가능한 공유기 개수를 countSet() 함수로 확인하도록 하였습니다.


## [내리막 길](https://www.acmicpc.net/problem/1520)
### 문제 풀이 방식
처음엔 당연히 bfs라고 생각했는데,, 재방문 관리를 하는 것이 불가능했고 풀이를 모르겠어서 정답 풀이를 보았고 DFS + dp 로 해결해야 하는 문제였습니다.
각 위치마다 방문 횟수를 저장할 memo라는 배열을 만들어서 관리하고 (0,0)부터 dfs로 탐색하였습니다.
- 최종 목적지(최하위 노드)인 (M-1, N-1)에 방문하면 1을 반환합니다.
- 상위노드의 방문 횟수는 하위노드의 방문 횟수를 더해서 저장한다.

    ex) 상위노드가 (i,j)이면 하위노드는 (i, j)로부터의 상하좌우 노드 중 방문 가능한 노드

이렇게 모든 탐색을 마치면 최상위 노드인 방문 시작점인 (0,0)의 방문값이 정답이 됩니다.
즉,`memo[0][0]`에 해당하는 값을 dfs함수에서 반환하게 됩니다.


## [디지털 티비](https://www.acmicpc.net/problem/2816)
### 문제 풀이 방식
스페셜 저지 문제이길래, 예시와는 다르게 나오지만 1, 4 버튼으로만 문제를 해결하도록 풀어보았습니다.  
방법의 길이는 500보다 작아야 한다는 제약 사항이 있지만 1, 4만 사용해도 최대길이가 100(채널길이) * 4 = 400 이므로 방법의 길이를 넘지 않아서 통과할 수 있었습니다.

- KBS1의 위치를 찾고 그 위치만큼 화살표를 이동 -> 1버튼을 KBS 위치 만큼 누르기
- 옮긴 화살표 위치에서 첫번쨰 위치까지 채널을 올리기 -> 4버튼을 KBS 위치 만큼 누르기

이러면 화살표가 다시 맨 위로 이동하므로 KBS도 동일하게 진행을 해주었습니다. 다만, KBS1이 더 아래에 위치해있는 경우 KBS2가 한칸 내려가게 되므로 해당 경우에는 이동횟수를 추가해주었습니다.  
`int move2 = idx1 > idx2 ? idx2 + 1 : idx2;`


## [A와 B 2](https://www.acmicpc.net/problem/12919)
### 문제 풀이 방식
S에 각 연산을 수행한 결과를 하나의 노드로 생각해서 탐색하면 되겠다고 생각하여 BFS로 구현을 하였습니다.

처음에는 S로부터 T를 만들었는데 각 연산을 수행한 결과를 모두 큐에 넣게되어서 메모리초과가 발생하였습니다. 그래서 지피티와 논의 후,,ㅎㅎ T에서 S를 만드는 방법으로 수정하여 불가능한 경우를 효율적으로 처리할 수 있도록 하였습니다.
