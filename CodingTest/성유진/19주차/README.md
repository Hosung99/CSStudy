## [공유기 설치](https://www.acmicpc.net/problem/2110)
### 문제 풀이 방식
양 끝 집에 공유기를 설치한 후, 남은 공유기를 이미 설치된 공유기와 최대한 멀리 설치하려고 하였습니다. 하지만 설치할 위치에 대한 명확한 기준을 세울수 없었고 그외의 풀이는 생각나지 않아서 다른 풀이를 참고하였습니다.  
항상 이진 탐색인 것은 깨닫는데 문제 풀이 자체를 떠올리지 못하네요,, 이진탐색 문제를 많이 풀어봐야 겠습니다..!

아무튼 그래서 보장해야 하는 최대 거리를 1부터 가장 먼 두 공유기의 거리까지 이진 탐색하며, 해당 거리를 보장하면서 설치 가능한 공유기 개수를 countSet() 함수로 확인하도록 하였습니다.


## [내리막 길](https://www.acmicpc.net/problem/1520)
### 문제 풀이 방식
처음엔 당연히 bfs라고 생각했는데,, 재방문 관리를 하는 것이 불가능했고 풀이를 모르겠어서 정답 풀이를 보았고 DFS + dp 로 해결해야 하는 문제였습니다.
각 위치마다 방문 횟수를 저장할 memo라는 배열을 만들어서 관리하고 (0,0)부터 dfs로 탐색하였습니다.
- 최종 목적지(최하위 노드)인 (M-1, N-1)에 방문하면 1을 반환합니다.
- 상위노드의 방문 횟수는 하위노드의 방문 횟수를 더해서 저장한다.

    ex) 상위노드가 (i,j)이면 하위노드는 (i, j)로부터의 상하좌우 노드 중 방문 가능한 노드

이렇게 모든 탐색을 마치면 최상위 노드인 방문 시작점인 (0,0)의 방문값이 정답이 됩니다.
즉,`memo[0][0]`에 해당하는 값을 dfs함수에서 반환하게 됩니다.


## [A와 B 2](https://www.acmicpc.net/problem/12919)
### 문제 풀이 방식
S에 각 연산을 수행한 결과를 하나의 노드로 생각해서 탐색하면 되겠다고 생각하여 BFS로 구현을 하였습니다.

처음에는 S로부터 T를 만들었는데 각 연산을 수행한 결과를 모두 큐에 넣게되어서 메모리초과가 발생하였습니다. 그래서 지피티와 논의 후,,ㅎㅎ T에서 S를 만드는 방법으로 수정하여 불가능한 경우를 효율적으로 처리할 수 있도록 하였습니다.
