## [단지번호붙이기](https://www.acmicpc.net/problem/2667)
### 문제 풀이 방식
정석적인 BFS 문제!  
입력받은 지도를 board에 저장하고 방문하면 -1로 갱신해주며, BFS로 탐색하였습니다.


## [숨바꼭질 4](https://www.acmicpc.net/problem/13913)
### 문제 풀이 방식
1. 동생을 찾을 수 잇는 가장 빠른 시간
2. 수빈이가 이동하는 위치
이렇게 두 가지 정보를 알아내야 했던 문제였습니다.

1번은 현재 위치에서 갈 수 있는 위치, 즉 -1, +1 *2 위치를 방문하며 BFS로 동생의 위치에 도달할 때까지 탐색하였습니다.  
시간이 흐름에 따라서 방문 가능한 위치들을 확인하고, time 이라는 배열에 `time[위치] = 시간` 형식으로 해당 위치의 방문 여부와 방문하는데에 걸리는 시간을 저장하였습니다.

2번을 알아낼 방법이 떠오르지 않아서 이전에 풀었던 풀이를 보고서 해결하였습니다.  
before라는 배열을 만들어서 현재 방문한 위치 직전에 방문했던 위치를 저장하도록 하였습니다. `before[현재위치] = 이전위치`  
도착지인 동생의 위치에서부터 before배열의 값을 순회하며 방문한 위치들을 배열에 담아주었고, 그 배열을 거꾸로 출력하여 해결하였습니다.


## [안전 영역](https://www.acmicpc.net/problem/2468)
### 문제 풀이 방식
이 문제도 전형적인 BFS 문제  
탐색할 때에 h를 인자로 받아서 안전 영역인지(h보다 큰 수인지)만 확인해주면 되었습니다.


## [일루미네이션](https://www.acmicpc.net/problem/5547)
### 문제 풀이 방식
용어정리 - 1 : 건물(검은색), 2: 외부(흰색)

처음에는 단순히 한칸씩 확인하면서 1마다 주위의 0의 개수를 세어서 모두 더하는 방식으로 구현하려고 하였습니다.   
예제처럼 1로 둘러쌓인 0의 경우는 바깥 영역으로 세어서는 안되기 때문에 개수를 세기 전에 주위 6칸이 모두 1로 둘러쌓여있는지 확인하려고 하였습니다. 하지만 여러개의 0이 묶여서 1로 둘러쌓이는 경우에는 처리할 수 없었습니다.  
그래서 기존에 떠올린 방식으로는 해결할 수 없다는 것은 깨달았으나 구현 방식이 떠오르지 않아 다른 코드를 보고 구현하였습니다.

처음에는 1을 기준으로 생각하였는데, 다른 코드를 살펴보니 **0을 기준으로 탐색하며 인접한 1의 수를 모두 더한 값**으로 문제를 해결하더군요..  
입력값으로 들어오지는 않지만 외부 테두리도 모두 0과 동일하게 더해야 하는 벽면이기 때문에 0, W+1, H+1도 0으로 채워서 board를 만들었습니다.  
그리고 0을 기준으로 탐색하며 0과 인접한 1의 개수를 세어주었습니다.
