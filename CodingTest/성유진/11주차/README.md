## [볼 모으기](https://www.acmicpc.net/problem/17615)
### 문제 풀이 방식
문제 유형 스택일거라고 생각하고 풀었는데 아니었네요...?  
우선 색을 분리하기 위해서는 오른쪽이든 왼쪽이든 맨 끝으로 보내야 한다고 생각하였습니다.  
그래서 파란공/빨간공을 각각 맨 왼쪽/오른쪽으로 모으는 경우,  
이렇게 4가지의 경우에 대해 확인하여 최솟값을 결과로 출력하였습니다.

동일한 색상의 공은 뛰어넘어서 이동할 수 있기 때문에 여기서 스택을 활용하면 좋겠다고 생각하였고,  
공의 이동횟수를 구하는 move 함수를 따로 분리하여 구현하였습니다.

move 함수에서는 이동시킬 공의 색상을 color 인자로 받아와서  
해당 색상이면 스택에 담아두었다가, 다른 색상을 만나면 스택에 담겨있던 공을 이동시키도록 (실제로 이동하지는 않지만 이동 횟수를 증가시키도록) 하였습니다.

```java
int cnt = 0; // 이동횟수
for (int i = 0; i < N; i++) {
  if (arr[i] == color) { // 이동시키려는 공을 스택에 담기
    S.push(arr[i]);
  } else {  // 다른 색깔 공 넘어가기
    while (!S.isEmpty()) { // 이동해야 했던 공을 이동 (이동 횟수 증가)
      S.pop();
      cnt++;
    }
  }
}
```
색깔은 move함수에서 입력받은 인자로부터 구분하였고, 공을 이동시키는 방향은 arr함수를 뒤집는 reverseArr 를 구현하여 바꾸어주었습니다.



## [시험 감독](https://www.acmicpc.net/problem/13458)
### 문제 풀이 방식
숫자 범위 고려하는게 핵심이었던 문제...! 였는데 알아서 해결 못하고 질문게시판을 보고 해결하였습니다..ㅜ 숫자 범위도 앞으로 유의해서 문제를 해결해야 겠습니다.

총감독관이 감독 가능한 사람 수를 빼고,  
남은 사람의 수를 부감독관이 감독 가능한 수로 나누어서 몫만큼 더해주었습니다.  
나누어 떨어지지 않는 경우는 추가로 1을 더해주었습니다.

```java
// 총감독관
A[i] -= B;
ans++;
// 부감독관
if (A[i] > 0) {
  ans += A[i] / C;
  if (A[i] % C > 0)
    ans++;
}
```

## [진우의 달 여행 (Small)](https://www.acmicpc.net/problem/17484)
### 문제 풀이 방식
BFS로 시도하다가 DP로 푸는게 더 적절할 것 같아서 DP로 해결하였습니다.

cost라는 배열에 해당 위치까지 이동하는 최소 비용값을 기록하였는데, 3가지 방향에 따라서 각각 저장하기 위해 3차원 배열에 저장하였습니다.  

`cost[i][j][d]` : d 방향으로 이동한 경우, (i, j)위치까지 이동하는 최소 비용값
- d : 0 -> **왼쪽 위**에서 이동하여 (i, j)에 도착한 경우
- d : 1 -> **바로 위**에서 이동하여 (i, j)에 도착한 경우
- d : 2 -> **오른쪽 위**에서 이동하여 (i, j)에 도착한 경우

`cost[i][j][d] = findMin(cost[i-1][idx], d) + space[i][j];`  
따라서 반복문을 순회하며 위와 같이 cost 배열의 값을 할당해주었고,  
최솟값인지를 확인하기 위해서 동일한 방향이 아닌지 여부를 확인하여 최솟값을 반환하는 findMin 함수를 만들었습니다.

`