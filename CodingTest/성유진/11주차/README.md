## [시험 감독](https://www.acmicpc.net/problem/13458)
### 문제 풀이 방식
숫자 범위 고려하는게 핵심이었던 문제...! 였는데 알아서 해결 못하고 질문게시판을 보고 해결하였습니다..ㅜ 숫자 범위도 앞으로 유의해서 문제를 해결해야 겠습니다.

총감독관이 감독 가능한 사람 수를 빼고,  
남은 사람의 수를 부감독관이 감독 가능한 수로 나누어서 몫만큼 더해주었습니다.  
나누어 떨어지지 않는 경우는 추가로 1을 더해주었습니다.

```java
// 총감독관
A[i] -= B;
ans++;
// 부감독관
if (A[i] > 0) {
  ans += A[i] / C;
  if (A[i] % C > 0)
    ans++;
}
```

## [진우의 달 여행 (Small)](https://www.acmicpc.net/problem/17484)
### 문제 풀이 방식
BFS로 시도하다가 DP로 푸는게 더 적절할 것 같아서 DP로 해결하였습니다.

cost라는 배열에 해당 위치까지 이동하는 최소 비용값을 기록하였는데, 3가지 방향에 따라서 각각 저장하기 위해 3차원 배열에 저장하였습니다.  

`cost[i][j][d]` : d 방향으로 이동한 경우, (i, j)위치까지 이동하는 최소 비용값
- d : 0 -> **왼쪽 위**에서 이동하여 (i, j)에 도착한 경우
- d : 1 -> **바로 위**에서 이동하여 (i, j)에 도착한 경우
- d : 2 -> **오른쪽 위**에서 이동하여 (i, j)에 도착한 경우

`cost[i][j][d] = findMin(cost[i-1][idx], d) + space[i][j];`  
따라서 반복문을 순회하며 위와 같이 cost 배열의 값을 할당해주었고,  
최솟값인지를 확인하기 위해서 동일한 방향이 아닌지 여부를 확인하여 최솟값을 반환하는 findMin 함수를 만들었습니다.

`