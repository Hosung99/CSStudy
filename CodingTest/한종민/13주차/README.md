## 애너그램
n과 m 처럼 백트래킹으로 풀었더니 메모리 초과가 나버렷다, 딮식쿠 한테 맡겨보았는데 이런 조건을 추가 해주었다. 이유를 모르겠다 천천히 생각해보아야겟다.

```java
    if (i > 0 && arr[i] == arr[i - 1] && visited[arr[i - 1] - 'a'] > 0) {
        continue;
    }
```

이 코드 말고는 재귀말고 그냥 stack으로 풀면 풀릴것 같긴하다..

## 부분합
이건 투포인터 기본 문제였다.\
근데 투포인터는 당연히 정렬되어있을때만 된다는 이상한 기억이 남아있어서 오름차순으로 만들려고 누적합으로 풀엇고, \
누적합으로 푸니까 시간 초과가 나버렷다.. \
아마도 누적합도 잘못 풀었겟지....;; \
지금 와서 생각해보면 누적합으로 풀면 거의 이중 포문이 되는것 같다

그래서 투포인터 다시 공부하고 다시 정석대로 풀엇다 휴

## 쉽게 푸는 문제
이건 왜 브론즈 1일까\
내가 누적합으로 풀려고해서 그런걸까요\
일단 코드는1 2 2 3 3 3 4 4 4 이 배열들을 누적합으로 만들고 입력으로 들어온 인덱스로 결과 찾아서 출력했다
누적합 배열 만드는데 머리가 조금 아팟다 이게 왜 어렵지..
```java
dp[0] = 0;
int index = 1;
int num = 1;
while (index < 1001) {
    int count = 0;
    while (count < num && index + count < 1001) {
        int currentIndex = index + count;
        dp[currentIndex] = dp[currentIndex - 1] + num;
        count++;
    }
    index += count;
    num++;
}
```
