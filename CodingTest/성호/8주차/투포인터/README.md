# 문제 1 회전초밥

## 문제 흐름

문제가 잘 이해가 안되서.. 답을 보았다 ㅠㅠ

초밥들의 종류별 개수를 저장한다.

시작점인 i와 끝점인 j를 증가시키면서 연속된 k개의 초밥을 1개씩 갱신해나간다.

즉, i번째 초밥을 버리고 (j + 1)번째 초밥을 추가하는 것이다. 여기서 (j + 1)이 N이 되면 회전 초밥이기 때문에 0으로 바꿔야 한다.

i번째 초밥을 버릴 때 만약 i번째 초밥 종류가 단 1개라면 i번째 초밥을 버리면서 한 종류의 초밥을 선택하지 않게 되는 것이므로 count를 감소시킨다.

그리고 (j + 1)번째 초밥 종류가 단 1개라면 없던 종류의 초밥이 새롭게 선택된 것이므로 count를 증가시킨다.

## 코드 설명

seq배열에 초밥들의 종류별 개수를 저장했다.

```js
if (seq[sushi[j]]) {
  seq[sushi[j]]++;
} else {
  seq[sushi[j]] = 1;
  count++;
}
maxCount = Math.max(maxCount, count + !seq[c]);
```

# 문제 2 가장 긴 짝수 연속한 부분수열

## 문제 흐름

O(N^2)으론 문제를 못푼다.

투포인터를 이용해서 O(N)안에 해결해보려고 했다.

수열의 각 원소들을 시작점으로 잡았을 때, 최대 K개의 홀수를 제거하여 만들 수 있는 짝수 수열의 최대 길이를 계산하고, 이중 가장 긴 길이를 출력하면 될 것 같았다.

seq[st]가 홀수라면, 수열의 시작점이 st + 1, 끝점이 en일 때, 홀수의 개수는 cnt - 1개

seq[st]가 짝수라면, 수열의 시작점이 st + 1, 끝점이 en일 때, 홀수의 개수는 cnt개다.

## 코드 설명

```js
while (true) {
  while (en < n - 1) {
    if (seq[en + 1] & 1) {
      if (cnt < k) {
        cnt++;
      } else {
        break;
      }
    }
    en++;
  }
}
```
